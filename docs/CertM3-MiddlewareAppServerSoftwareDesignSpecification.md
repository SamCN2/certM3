Software Design Specification: CertM3 Go Middleware App Server

Version: 1.0
Date: May 29, 2025

1. Introduction

This document outlines the software design specification for the CertM3 Go Middleware App Server. This server will replace an existing Express.js middleware layer. It will act as a proxy and application server between browser clients and the Loopback 4 API backend. Its primary responsibilities include  handling JWT-based authentication and session management, proxying/interpreting API requests to the backend, basic SPA routing, and, critically, the temporary handling of Certificate Signing Request (CSR) signing.

This specification is informed by the provided openapi.yaml (detailing the backend API) and the data4gemini requirements document, as well as the interactive Q&A session. The goal is to create a specification detailed enough for implementation by a development team or a capable Large Language Model.

2. Guiding Principles

    Security First: The design must prioritize security, especially concerning private key handling and CSR operations.
    Performance: The Go implementation should be efficient and have low latency.
    Maintainability: The codebase should be well-structured and easy to understand.
    Testability: The system must be designed for comprehensive testing.
    Clarity: Explicit configurations and avoidance of ambiguity (e.g., no "localhost" in production-like communication).
    App server will exist behind nginx reverse proxy (even, especially during testing) with TLS and FQDN

3. Architecture

3.1. Overview

The Go middleware will be a standalone HTTP server. It will:
1. Serve static assets (HTML, CSS, JavaScript) for the Single Page Application (SPA).
2. Authenticate users via JWTs.
3. Handle specific application flows by interpreting client requests and then making appropriate calls to the backend CertM3 API server.
4. Directly proxy certain utility API calls (e.g., username availability check).
5. Temporarily, sign CSRs generated by the client. This functionality is slated to move to the API backend in a future phase.
6. Communicate with the backend API server exclusively via mTLS over HTTPS, using fully qualified domain names (FQDNs).

3.2. Components & Package Structure

The Go application will be structured into logical packages:

    main:
        Entry point of the application.
        Handles initialization of configuration, logging, and other global resources.
        Starts the HTTP server.
    config:
        Responsible for loading, parsing, and providing access to application configuration (from environment variables or a configuration file).
        Key configurations: API_BASE_URL, APP_BASE_URL, JWT_SECRET, RATE_LIMIT_PER_SECOND, MTLS_CERT_PATH, MTLS_KEY_PATH, MTLS_CA_PATH, CSR_SIGNING_CERT_PATH, CSR_SIGNING_KEY_PATH, LOG_LEVEL.
    server (or http or api):
        Defines the main HTTP server setup.
        Manages routing and dispatches requests to appropriate handlers.
    handlers:
        Contains HTTP handler functions for different routes/responsibilities.
        static_handler.go: Serves static files.
        auth_handler.go: Handles JWT validation logic.
        proxy_handler.go: Handles proxying to the backend API. This will include both direct proxying and interpreted proxying.
        csr_handler.go: Handles CSR submission and signing.
        app_logic_handler.go: Handles requests that require interpretation before backend calls (e.g., initiating a certificate request process).
    routing:
        Defines all application routes and maps them to handlers.
        Manages middleware chains for concerns like authentication, logging, rate limiting.
        Will use a standard Go router (e.g., net/http.ServeMux for simplicity, or a lightweight third-party router like gorilla/mux or chi if more complex patterns are needed, though simplicity is preferred).
    auth:
        JWT validation logic.
        Functions to create/parse JWTs. JWTs will include userID and requestID to securely link actions.
        Interaction with request headers for token extraction.
    proxy:
        Contains logic for forwarding requests to the backend CertM3 API.
        Utilizes net/http/httputil.ReverseProxy for direct proxying needs (e.g., /request/check-username/{username}).
        Contains functions to construct and send requests to the backend API for interpreted flows, using the http.Client configured for mTLS.
    security:
        Implementation of security measures:
            Rate limiting middleware (configurable, default 1 request/second per source IP).
            Functions for setting secure HTTP headers (CSP, HSTS, XSS protection, etc.).
            mTLS client configuration for backend communication.
    csr:
        Logic for handling and signing CSRs. This includes validating the CSR and using a securely stored private key (distinct from user browser keys) to sign it.
    logging:
        Utility functions for structured logging (e.g., JSON format).
        Provides consistent logging context (e.g., request IDs).
    utils (optional):
        Common utility functions.

3.3. Data Flow

    User Registration/Certificate Request Initiation:
        Client sends user details (email, username, display name) to a middleware endpoint.
        Middleware validates input.
        Middleware forwards request to backend API to create a "request" record (see openapi.yaml, POST /requests). API sends validation email.
    Email Validation:
        User clicks validation link, which directs them to a frontend page.
        Frontend sends challenge token to a middleware endpoint.
        Middleware forwards validation to backend API (POST /requests/{id}/validate).
        On success, backend API marks request as validated and creates the user. Middleware receives userID.
        Middleware generates a JWT containing userID and the original requestID, returns it to the client.
    CSR Generation & Submission:
        Client (browser) generates a key pair (private key never leaves the browser).
        Client generates a CSR using the public key.
        Client sends CSR to the middleware, along with the JWT for authentication.
    CSR Signing (Temporary Middleware Responsibility):
        Middleware validates JWT and extracts userID and requestID.
        Middleware logs the CSR operation (validated username, email, requestID).
        Middleware signs the CSR using its own securely configured signing key and certificate.
        Middleware returns the signed certificate to the client.
    Certificate Storage:
        Client browser wraps the signed certificate and the user's private key into a PKCS12 package for local storage.
    General API Interaction:
        Client makes requests to middleware.
        Middleware authenticates via JWT.
        Middleware either directly proxies (e.g., /request/check-username/{username}) or interprets the request, makes necessary calls to the backend API via mTLS, and returns the response.

3.4. Error Handling

    Consistent error responses (JSON format) for API-like interactions.
    Use standard HTTP status codes.
    Detailed logging of errors on the server-side for debugging, without exposing sensitive information to the client.
    Clear distinction between client errors (4xx) and server errors (5xx).

4. Implementation Details

4.1. Static File Serving
* Implement proper caching headers (e.g., Cache-Control, ETag).
* Support for SPA: all non-asset/non-api routes should serve index.html.
* middleware server should only serve JSON, front end app is SPA, which will load from index.html via nginx.
* Frontend will use Vuetify 3 (Material Design) for UI components, chosen for its native Vue 3 support and comprehensive component library.

4.2. JWT Authentication
* Use a reputable Go JWT library (e.g., github.com/golang-jwt/jwt/v5).
* JWTs will be passed in the Authorization: Bearer <token> header.
* JWTs will contain userID and requestID claims, along with standard claims (exp, iat).
* The JWT secret will be configured via environment variables.
* Middleware will validate the token signature and expiration on relevant requests.

4.3. API Proxying & Interpretation
* Direct Proxy: For /app/request/check-username/{username}, use httputil.ReverseProxy.
* The target URL will be constructed using API_BASE_URL.
* The mTLS client will be used for this proxy.
* Interpreted Requests: For other interactions, the middleware handlers will:
* Validate the incoming request (and JWT).
* Make one or more calls to the backend API using a standard http.Client configured for mTLS.
* The API_BASE_URL will be used to construct backend request URLs.
* Transform/combine backend responses as needed before replying to the client.
* mTLS to Backend:
* All communication to the API_BASE_URL must use mTLS.
* mTLS will be setup with nginx reverse proxy.
* The Go http.Client will be configured with client certificate, client key, and CA certificate. Paths to these PEM-encoded files will be from config.
* Crucially: Always use FQDNs for API_BASE_URL. No localhost or raw IP addresses.

4.4. Routing
* Main router defined in routing package.
* Define routes for:
* Static assets (/, /static/*, index.html).
* Application logic endpoints (e.g., /app/initiate-request, /app/submit-csr).
* Proxied API endpoints (e.g., /api/check-username/{username}).
* Health check endpoint (e.g., /health or reuse /ping from openapi.yaml by proxying).
* Middleware chain: logging -> rate limiting -> auth (for protected routes) -> handler.
* App endpoints can have /app prepended by reverse proxy (ngnix)
* Server _will_ run behind nginx reverse proxy

4.5. CSR Signing (Temporary)
* An endpoint (e.g., /app/sign-csr) will accept a CSR from an authenticated client.
* The CSR will be parsed and validated.
* The middleware will load its own CSR signing private key and certificate (configured via CSR_SIGNING_KEY_PATH and CSR_SIGNING_CERT_PATH). This key MUST be protected rigorously.
* The CSR will be signed using this key.
* The resulting signed certificate will be returned to the client.
* This entire operation must be logged with userID, requestID, validated email and username (as discussed).

4.6. Security Measures
* HTTPS: The Go server itself should run behind a reverse proxy (like Nginx) that terminates HTTPS, or serve HTTPS directly if appropriate for the deployment environment. For simplicity, this spec assumes a reverse proxy handles HTTPS termination for incoming client connections.
* Secure Headers:
* Content-Security-Policy
* Strict-Transport-Security (HSTS)
* X-Content-Type-Options: nosniff
* X-Frame-Options: DENY
* X-XSS-Protection: 1; mode=block
* Rate Limiting: Implemented per source IP, configurable (e.g., 1 req/sec default). Store request counts in memory with expiry (e.g., using a map with mutex or a dedicated library).
* Input Validation: Validate all incoming data (path parameters, query parameters, request bodies) against expected formats and constraints.
* CORS: Configure CORS appropriately if the frontend is served from a different origin than the middleware API endpoints. Given it serves static files, this might be simpler if paths are aligned. However, explicit CORS headers (Access-Control-Allow-Origin, etc.) should be configurable. Since only JSON is expected for API interactions, content-type validation can be strict.
* mTLS to Backend: As detailed in 4.3.

4.7. Configuration
* Hierarchical configuration: environment variables override config file values.
* A struct in the config package will hold all configuration values.
* Example config parameters:
* API_BASE_URL: FQDN URL for the backend Loopback API server.
* APP_BASE_URL: FQDN URL for the frontend application (used for constructing redirect URLs, etc.).
* JWT_SECRET: Secret key for signing and verifying JWTs.
* RATE_LIMIT_PER_SECOND: Integer for rate limiting.
* LOG_LEVEL: (e.g., DEBUG, INFO, WARN, ERROR).
* Paths for mTLS certs and CSR signing certs/keys.
* Static files directory path.
* HTTP server port.

4.8. Logging and Monitoring
* Structured Logging: Use a library like logrus or zap, or build on log/slog (Go 1.21+) for JSON formatted logs.
* Log essential information for each request: timestamp, method, path, status code, duration, request ID.
* Log errors with stack traces (if appropriate) and relevant context.
* Critical Operations Logging: For CSR signing, log: validated username, validated email address, and requestID. Do not log IP addresses directly for this; they can be correlated from Nginx logs if needed.
* Health Check Endpoint: A simple /health endpoint returning HTTP 200 OK.
* Metrics: Consider exposing basic Prometheus metrics (e.g., request counts, error rates, latencies) if monitoring infrastructure supports it. (Standard library expvar can be a simple start).

5. Development

5.1. Build Process
* Standard Go build tools (go build).
* Use Go modules for dependency management (go.mod, go.sum).

5.2. Testing Strategy
* Unit Tests: Test individual functions and methods in isolation. Focus on business logic within handlers, utility functions, and auth/security components. Use Go's standard testing package. Table-driven tests are encouraged.
* Integration Tests: Test interactions between components (e.g., routing to handlers, middleware execution). May involve starting a test instance of the server and making HTTP requests to it.
* Test API proxying logic with a mock backend server.
* Test mTLS client configuration against a mock mTLS server.
* Test CSR signing logic (ensure valid certs are produced).
* Mocking: Use interfaces and dependency injection to allow mocking of external services (like the backend API) and system resources (like time) during tests.
* Test Data: Maintain a set of test data, including sample CSRs, JWTs, and certificates.

5.3. Security Guidelines for Developers
* Never log private keys or JWT secrets.
* Sanitize all inputs.
* Follow secure coding practices.
* Regularly update dependencies.
* Be mindful of the temporary nature of CSR signing in the middleware and ensure logging is sufficient for audit.

5.4. mTLS Testing
* Generate test CA, server, and client certificates for mTLS testing locally.
* Write integration tests that verify successful mTLS handshake and communication with a mock backend.

6. Deployment

6.1. Deployment Process
* Package the application as a statically linked Go binary.
* Consider containerizing the application using Docker for consistent deployments.
* Configuration should be supplied via environment variables in the deployment environment.

6.2. Monitoring
* Integrate application logs with a centralized logging system (e.g., ELK stack, Splunk).
* Monitor key metrics (error rates, request latency, resource usage).

6.3. Maintenance
* Regularly update Go version and dependencies.
* Backup configuration and sensitive materials (like the CSR signing key, if not managed by a HSM or vault).

6.4. Scaling
* The middleware should be designed to be stateless to facilitate horizontal scaling. JWTs help with this.
* Rate limiting state (if in-memory) might require a distributed solution (e.g., Redis) if scaled across multiple instances, or use sticky sessions at the load balancer if simpler. For the expected low volume, instance-local rate limiting might be acceptable initially.

6.5. Security Hardening
* Run the application with the least privilege.
* Ensure all sensitive configuration (JWT secret, private keys) is managed securely (e.g., using environment variables injected by a secrets management system like HashiCorp Vault or Kubernetes Secrets).
* The CSR signing key used by the middleware is highly sensitive and must be protected.

6.6. Certificate Management
* Establish procedures for managing and rotating mTLS client certificates and the middleware's CSR signing certificate.

7. Testability (Summary of Design Choices for Testability)

    Interface-Based Design: Define interfaces for dependencies (e.g., backend API client, CSR signer) to allow for easy mocking.
    Dependency Injection: Pass dependencies to components rather than creating them internally.
    Clear Separation of Concerns: Modular package structure.
    Mocking Strategy: Use Go's interface capabilities and tools like gomock or manual mocks.
    Test Data Management: Store test CSRs, keys, certs, and API responses in test-specific directories.
    Observability in Tests: Ensure logs can be captured and asserted during tests.
    Configurable Behavior for Tests: Allow overriding configuration for test environments.
    Health Check Endpoints: Useful for integration test setup.

8. Future Considerations

    CSR Signing Migration: The design should not make it overly complex to remove the CSR signing functionality when it moves to the API backend. The csr package and its handlers should be relatively self-contained.
    API Backend Changes: By interpreting many requests rather than blindly proxying all, the middleware is somewhat coupled to the backend API logic. However, using the openapi.yaml as a contract and having clear separation should aid in adapting to backend changes.
    Rust Rewrite: This Go middleware is a step towards a potential future Rust backend. The clear interfaces and responsibilities defined here can serve as a good model for that eventual rewrite.

Codicil: Middleware Specification for Signer Compatibility

Version: 1.0
Date: May 31, 2025
Reference: CSR Signing Service Specification v1.0

1. Preamble

This document serves as a codicil to the primary specification for the Middleware Go application. It details the requirements for the middleware to successfully and securely interact with the Go CSR Signing Service (as defined in the Signer Spec). The middleware's primary responsibilities in this context include authenticating users, validating their role/group entitlements, generating Certificate Signing Requests (CSRs) or processing user-submitted CSRs, preparing requests for the signer service, communicating with the signer service, and handling its responses.

2. Signer Service Interaction

2.1. Client Role & Communication Protocol
* The middleware shall act as a client to the Signer service.
* Communication shall occur exclusively over a UNIX domain socket, the path to which is configurable in the middleware.

2.2. Request Payload Preparation
* The middleware is responsible for constructing a JSON request payload for the Signer service. This payload must adhere strictly to the "Input JSON Structure" defined in Section 5 of the Signer Spec. This includes:
* csr_pem: A PEM-encoded CSR string.
* subject_common_name: The desired Common Name for the certificate's Subject DN.
* validated_email: The user's validated email address for the SAN rfc822Name.
* authorized_roles: An array of strings representing the user's validated roles/groups to be included in the custom certificate extension.
* The middleware must ensure that the authorized_roles sent to the signer are the result of its own internal authentication and authorization logic, reflecting the user's actual entitlements. The signer trusts the middleware to perform this validation.

2.3. Response Handling
* The middleware must be capable of parsing all JSON response structures defined in Section 6 of the Signer Spec:
* Success Response (Normal Mode) (Signer Spec Section 6.1)
* Error Response (Signer Spec Section 6.2)
* Success Response (Signer Test API Endpoint Mode) (Signer Spec Section 6.3)
* Upon receiving a successful response containing certificate_pem, the middleware shall make this certificate available to the end-user or initiating system.
* Upon receiving an error response, the middleware shall log the error from the signer and translate it into an appropriate error for its own client.
* When interacting with the signer in its -T (Test API Endpoint Mode), the middleware should correctly interpret the test mode response and potentially display the proposed certificate data for debugging or integration testing purposes.

3. Certificate Request Workflow (Illustrative)

The following outlines a typical workflow within the middleware related to certificate issuance:

    Intake: Receive a request for a certificate from an end-user or an automated system via its own API (e.g., an HTTPS endpoint). This request should implicitly or explicitly identify the user.
    Authentication: Authenticate the requesting user/system.
    Authorization & Role Validation: Based on the authenticated identity, determine the user's entitlements. If the user requests specific roles, validate these against their entitlements. Compile the final, authoritative list of authorized_roles.
    Information Gathering:
        Determine the appropriate subject_common_name for the certificate (e.g., username, full name).
        Retrieve/confirm the validated_email address for the user.
    CSR Generation:
        The middleware shall generate a new cryptographic key pair (e.g., RSA or ECDSA, based on internal policy or configuration).
        The middleware shall then generate a CSR using the new public key and incorporating necessary subject information (this subject information in the CSR itself can be minimal, as the signer will use the JSON-provided subject_common_name and its own configuration for the final certificate's Subject DN).
        The generated CSR is then PEM-encoded to become the csr_pem field.
        (Alternative: The middleware could accept a user-submitted CSR, in which case it would skip key pair generation but must still validate the CSR before sending it to the signer.)
    Signer Request: Construct the JSON payload (as per Section 2.2 above) and send it to the Signer service over the UNIX domain socket.
    Process Response: Handle the signer's JSON response (as per Section 2.3).
    Deliver/Store Certificate: If successful, deliver the PEM-encoded certificate to the user/system. The private key generated in step 5a must also be securely delivered to the user (e.g., for download in a PKCS#12 bundle, or if the middleware is part of a larger device enrollment flow, provisioned securely). Secure handling and delivery of the private key is critical and a core responsibility of the middleware in this flow.
    Logging: Log all significant steps, including the roles requested, roles authorized, and the outcome of the interaction with the signer.

4. Middleware Configuration File (Sketch)

The middleware shall use a configuration file (e.g., middleware-config.ini) with attribute = value pairs. Key parameters relevant to signer interaction and general operation include:

    # Middleware Service Configuration
    ListenAddress = :8443
    TLSCertPath = /etc/middleware/certs/middleware-cert.pem
    TLSKeyPath = /etc/middleware/certs/middleware-key.pem
    # Logging
    LogFilePath = /var/log/middleware/middleware.log
    LogLevel = INFO
    # Signer Service Connection
    SignerSocketPath = /var/run/myapp/signer.sock
    SignerRequestTimeoutSeconds = 10
    # Certificate Generation Defaults (for CSRs created by middleware)
    CSRDefaultKeyAlgorithm = ECDSA # Options: RSA, ECDSA
    CSRDefaultKeyCurve = P256 # Options: P256, P384, P521 (if ECDSA)
    CSRDefaultKeyBits = 2048 # (if RSA)
    CSRDefaultSignatureAlgorithm = SHA256 # e.g., SHA256, SHA384

5. Error Handling & Resilience (Signer Interaction)

    The middleware must gracefully handle connection errors when attempting to communicate with the SignerSocketPath (e.g., if the signer service is down or the socket is not available).
    It should implement a configurable timeout (SignerRequestTimeoutSeconds) for requests to the signer.
    In cases where the signer is unavailable or a request times out, the middleware should:
        Log the error with sufficient detail.
        Return an appropriate error message to its own client (e.g., HTTP 503 Service Unavailable or HTTP 504 Gateway Timeout).
        Consider implementing a retry mechanism with backoff for transient connection issues, if appropriate for the user experience.
    The middleware should have its own health check endpoint, which should report as unhealthy if it cannot connect to the signer service, as this is a critical dependency.

This codicil provides the necessary linkage points to ensure your middleware application can effectively and securely utilize the CSR Signing Service.
